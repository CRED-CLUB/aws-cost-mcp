import boto3
import logging
from typing import List, Dict, Optional, Any
from dotenv import load_dotenv
from .utils import (
    filter_none_params, 
    datetime_serializer, 
    get_athena_database, 
    get_athena_workgroup, 
    get_athena_output_location
)
import json

logger = logging.getLogger(__name__)
load_dotenv()

class AthenaClient:
    """
    Client for interacting with AWS Athena APIs.
    """

    def __init__(self):
        """
        Initialize the Athena client.
        """
        self.athena_client = boto3.client("athena")

    def start_query_execution(
        self,
        query_string: str,
        database: Optional[str] = None,
        output_location: Optional[str] = None,
        work_group: Optional[str] = None,
        query_execution_context: Optional[Dict[str, str]] = None,
        result_configuration: Optional[Dict[str, Any]] = None,
        execution_parameters: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        Starts a query execution using Athena.

        Args:
            query_string (str): The SQL query statements to be executed.
            database (Optional[str]): The database in which the query execution occurs.
            output_location (Optional[str]): The location in Amazon S3 where query results are stored.
            work_group (Optional[str]): The name of the workgroup in which the query is being started.
            query_execution_context (Optional[Dict[str, str]]): The database within which the query executes.
            result_configuration (Optional[Dict[str, Any]]): Specifies information about where and how to save the results of the query execution.
            execution_parameters (Optional[List[str]]): A list of values for the parameters in a query.

        Returns:
            Dict[str, Any]: A dictionary containing the query execution ID.

        Raises:
            Exception: If an error occurs while starting query execution.
        """
        try:
            # Use environment variables as defaults if not provided
            if not database:
                database = get_athena_database()
            
            if not output_location:
                output_location = get_athena_output_location()
                
            if not work_group:
                work_group = get_athena_workgroup()
            
            # Prepare query execution context if database is provided but not the full context
            if database and not query_execution_context:
                query_execution_context = {"Database": database}
            
            # Prepare result configuration if output location is provided but not the full config
            if output_location and not result_configuration:
                result_configuration = {"OutputLocation": output_location}
            
            params = {
                'QueryString': query_string,
                'QueryExecutionContext': query_execution_context,
                'ResultConfiguration': result_configuration,
                'WorkGroup': work_group,
                'ExecutionParameters': execution_parameters
            }
            
            response = self.athena_client.start_query_execution(**filter_none_params(params))
            return response
        except Exception as e:
            logger.error("Error starting query execution: %s", str(e))
            raise

    def get_query_execution(self, query_execution_id: str) -> Dict[str, Any]:
        """
        Gets information about a single execution of a query.

        Args:
            query_execution_id (str): The unique ID of the query execution.

        Returns:
            Dict[str, Any]: A dictionary containing information about the query execution.

        Raises:
            Exception: If an error occurs while getting query execution.
        """
        try:
            response = self.athena_client.get_query_execution(
                QueryExecutionId=query_execution_id
            )
            return response
        except Exception as e:
            logger.error("Error getting query execution: %s", str(e))
            raise

    def get_query_results(
        self,
        query_execution_id: str,
        next_token: Optional[str] = None,
        max_results: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Returns the results of a query execution specified by query execution ID.

        Args:
            query_execution_id (str): The unique ID of the query execution.
            next_token (Optional[str]): A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
            max_results (Optional[int]): The maximum number of results (rows) to return in this request.

        Returns:
            Dict[str, Any]: A dictionary containing the query results.

        Raises:
            Exception: If an error occurs while getting query results.
        """
        try:
            params = {
                'QueryExecutionId': query_execution_id,
                'NextToken': next_token,
                'MaxResults': max_results
            }
            response = self.athena_client.get_query_results(**filter_none_params(params))
            return response
        except Exception as e:
            logger.error("Error getting query results: %s", str(e))
            raise

    def stop_query_execution(self, query_execution_id: str) -> Dict[str, Any]:
        """
        Stops a query execution.

        Args:
            query_execution_id (str): The unique ID of the query execution to stop.

        Returns:
            Dict[str, Any]: A dictionary containing the response.

        Raises:
            Exception: If an error occurs while stopping query execution.
        """
        try:
            response = self.athena_client.stop_query_execution(
                QueryExecutionId=query_execution_id
            )
            return response
        except Exception as e:
            logger.error("Error stopping query execution: %s", str(e))
            raise

    def list_query_executions(
        self,
        work_group: Optional[str] = None,
        next_token: Optional[str] = None,
        max_results: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Returns a list of query execution IDs.

        Args:
            work_group (Optional[str]): The name of the workgroup from which queries are being returned.
            next_token (Optional[str]): A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
            max_results (Optional[int]): The maximum number of query executions to return in this request.

        Returns:
            Dict[str, Any]: A dictionary containing the list of query execution IDs.

        Raises:
            Exception: If an error occurs while listing query executions.
        """
        try:
            params = {
                'WorkGroup': work_group,
                'NextToken': next_token,
                'MaxResults': max_results
            }
            response = self.athena_client.list_query_executions(**filter_none_params(params))
            return response
        except Exception as e:
            logger.error("Error listing query executions: %s", str(e))
            raise

    def list_databases(
        self,
        catalog_name: Optional[str] = None,
        next_token: Optional[str] = None,
        max_results: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Lists the databases in the specified data catalog.

        Args:
            catalog_name (Optional[str]): The name of the data catalog for which databases should be listed.
            next_token (Optional[str]): A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
            max_results (Optional[int]): The maximum number of databases to return in this request.

        Returns:
            Dict[str, Any]: A dictionary containing the list of databases.

        Raises:
            Exception: If an error occurs while listing databases.
        """
        try:
            params = {
                'CatalogName': catalog_name,
                'NextToken': next_token,
                'MaxResults': max_results
            }
            response = self.athena_client.list_databases(**filter_none_params(params))
            return response
        except Exception as e:
            logger.error("Error listing databases: %s", str(e))
            raise

    def list_table_metadata(
        self,
        database_name: str,
        catalog_name: Optional[str] = None,
        expression: Optional[str] = None,
        next_token: Optional[str] = None,
        max_results: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Lists the tables in the specified data catalog database.

        Args:
            database_name (str): The name of the database for which table metadata should be returned.
            catalog_name (Optional[str]): The name of the data catalog for which database metadata should be returned.
            expression (Optional[str]): A regex filter that pattern-matches table names.
            next_token (Optional[str]): A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
            max_results (Optional[int]): The maximum number of tables to return in this request.

        Returns:
            Dict[str, Any]: A dictionary containing the list of table metadata.

        Raises:
            Exception: If an error occurs while listing table metadata.
        """
        try:
            params = {
                'DatabaseName': database_name,
                'CatalogName': catalog_name,
                'Expression': expression,
                'NextToken': next_token,
                'MaxResults': max_results
            }
            response = self.athena_client.list_table_metadata(**filter_none_params(params))
            return response
        except Exception as e:
            logger.error("Error listing table metadata: %s", str(e))
            raise

    def run_query(
        self,
        query_string: str,
        database: Optional[str] = None,
        output_location: Optional[str] = None,
        work_group: Optional[str] = None,
        wait_for_completion: bool = True,
        poll_interval: int = 1,
        max_wait_time: int = 300
    ) -> Dict[str, Any]:
        """
        Runs a query and optionally waits for its completion.

        Args:
            query_string (str): The SQL query statements to be executed.
            database (Optional[str]): The database in which the query execution occurs.
            output_location (Optional[str]): The location in Amazon S3 where query results are stored.
            work_group (Optional[str]): The name of the workgroup in which the query is being started.
            wait_for_completion (bool): Whether to wait for the query to complete before returning.
            poll_interval (int): The interval in seconds to poll for query completion status.
            max_wait_time (int): The maximum time in seconds to wait for query completion.

        Returns:
            Dict[str, Any]: A dictionary containing the query execution details and results if wait_for_completion is True.

        Raises:
            Exception: If an error occurs while running the query or if the query times out.
        """
        import time
        
        try:
            # Use environment variables as defaults if not provided
            if not database:
                database = get_athena_database()
            
            if not output_location:
                output_location = get_athena_output_location()
                
            if not work_group:
                work_group = get_athena_workgroup()
                
            # Start the query execution
            start_response = self.start_query_execution(
                query_string=query_string,
                database=database,
                output_location=output_location,
                work_group=work_group
            )
            
            query_execution_id = start_response.get('QueryExecutionId')
            
            if not wait_for_completion:
                return {'QueryExecutionId': query_execution_id, 'Status': 'STARTED'}
            
            # Wait for the query to complete
            wait_time = 0
            while wait_time < max_wait_time:
                query_status = self.get_query_execution(query_execution_id)
                status = query_status.get('QueryExecution', {}).get('Status', {}).get('State')
                
                if status in ['SUCCEEDED', 'FAILED', 'CANCELLED']:
                    if status == 'SUCCEEDED':
                        # Get the query results
                        results = self.get_query_results(query_execution_id)
                        return {
                            'QueryExecutionId': query_execution_id,
                            'Status': status,
                            'QueryExecution': query_status.get('QueryExecution', {}),
                            'Results': results
                        }
                    else:
                        error_message = query_status.get('QueryExecution', {}).get('Status', {}).get('StateChangeReason', 'Unknown error')
                        return {
                            'QueryExecutionId': query_execution_id,
                            'Status': status,
                            'QueryExecution': query_status.get('QueryExecution', {}),
                            'ErrorMessage': error_message
                        }
                
                time.sleep(poll_interval)
                wait_time += poll_interval
            
            # If we've reached here, the query has timed out
            self.stop_query_execution(query_execution_id)
            return {
                'QueryExecutionId': query_execution_id,
                'Status': 'TIMEOUT',
                'ErrorMessage': f'Query execution timed out after {max_wait_time} seconds'
            }
            
        except Exception as e:
            logger.error("Error running query: %s", str(e))
            raise
